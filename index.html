<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Asher.zhang&apos;s blogs.">
<meta name="keywords" content="网站关键字, Android, Ktolin, Java, Life">
<meta property="og:type" content="website">
<meta property="og:title" content="Zmy">
<meta property="og:url" content="https://zmylls.github.io/index.html">
<meta property="og:site_name" content="Zmy">
<meta property="og:description" content="Asher.zhang&apos;s blogs.">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Zmy">
<meta name="twitter:description" content="Asher.zhang&apos;s blogs.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zmylls.github.io/"/>





  <title>Zmy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Zmy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Light dance and sunset</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Schedule
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            Commonweal 404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asher.zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zmy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/29/Activity启动过程(二)/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-29T11:14:02+08:00">
                2019-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Activity启动过程-二"><a href="#Activity启动过程-二" class="headerlink" title="Activity启动过程(二)"></a>Activity启动过程(二)</h1><p>上一篇文章，我们是通过一个Activity启动另一个Activity来说明Activity的启动过程。而这篇文章，笔者将从启动一个APP的角度来说明一个Activity的启动过程。</p>
<p>通常我们是通过点击手机桌面的快捷入口来启动一个APP的。手机桌面也是一个APP，这个APP的源代码就是<a href="http://androidxref.com/8.0.0_r4/xref/packages/apps/Launcher3/" target="_blank" rel="noopener">Launcher3</a>，它在/packages/apps/Launcher3/目录下。我们可以看到，这其实也就是一个APP的项目结构。</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487321554898.jpg" alt=""></p>
<p>从src目录点击去，找到Launcher.java文件<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487322574407.jpg" alt=""></p>
<p>这个Launcher是继承了一个BaseActivity,所以它也是一个Activivty。Launcher的界面布局、界面显示的信息，我们这里不做讨论。有兴趣的同学可以找下Launcher启动过程的相关文章。</p>
<p>用户在桌面上点击一个快捷键图片就可以打开一个APP，那肯定有个点击事件来触发这个操作，所以我们先来找找Launcher中的点击事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">2262 public void onClick(View v) &#123;</span><br><span class="line">2263        // Make sure that rogue clicks don&apos;t get through while allapps is launching, or after the</span><br><span class="line">2264        // view has detached (it&apos;s possible for this to happen if the view is removed mid touch).</span><br><span class="line">2265        if (v.getWindowToken() == null) &#123;</span><br><span class="line">2266            return;</span><br><span class="line">2267        &#125;</span><br><span class="line">2268</span><br><span class="line">2269        if (!mWorkspace.isFinishedSwitchingState()) &#123;</span><br><span class="line">2270            return;</span><br><span class="line">2271        &#125;</span><br><span class="line">2272</span><br><span class="line">2273        if (v instanceof Workspace) &#123;</span><br><span class="line">2274            if (mWorkspace.isInOverviewMode()) &#123;</span><br><span class="line">2275                getUserEventDispatcher().logActionOnContainer(LauncherLogProto.Action.Type.TOUCH,</span><br><span class="line">2276                        LauncherLogProto.Action.Direction.NONE,</span><br><span class="line">2277                        LauncherLogProto.ContainerType.OVERVIEW, mWorkspace.getCurrentPage());</span><br><span class="line">2278                showWorkspace(true);</span><br><span class="line">2279            &#125;</span><br><span class="line">2280            return;</span><br><span class="line">2281        &#125;</span><br><span class="line">2282</span><br><span class="line">2283        if (v instanceof CellLayout) &#123;</span><br><span class="line">2284            if (mWorkspace.isInOverviewMode()) &#123;</span><br><span class="line">2285                int page = mWorkspace.indexOfChild(v);</span><br><span class="line">2286                getUserEventDispatcher().logActionOnContainer(LauncherLogProto.Action.Type.TOUCH,</span><br><span class="line">2287                        LauncherLogProto.Action.Direction.NONE,</span><br><span class="line">2288                        LauncherLogProto.ContainerType.OVERVIEW, page);</span><br><span class="line">2289                mWorkspace.snapToPageFromOverView(page);</span><br><span class="line">2290                showWorkspace(true);</span><br><span class="line">2291            &#125;</span><br><span class="line">2292            return;</span><br><span class="line">2293        &#125;</span><br><span class="line">2294</span><br><span class="line">2295        Object tag = v.getTag();</span><br><span class="line">2296        if (tag instanceof ShortcutInfo) &#123;</span><br><span class="line">                //找到tag对应一个快捷键</span><br><span class="line">2297            onClickAppShortcut(v);</span><br><span class="line">2298        &#125; else if (tag instanceof FolderInfo) &#123;</span><br><span class="line">2299            if (v instanceof FolderIcon) &#123;</span><br><span class="line">2300                onClickFolderIcon(v);</span><br><span class="line">2301            &#125;</span><br><span class="line">2302        &#125; else if ((FeatureFlags.LAUNCHER3_ALL_APPS_PULL_UP &amp;&amp; v instanceof PageIndicator) ||</span><br><span class="line">2303                (v == mAllAppsButton &amp;&amp; mAllAppsButton != null)) &#123;</span><br><span class="line">2304            onClickAllAppsButton(v);</span><br><span class="line">2305        &#125; else if (tag instanceof AppInfo) &#123;</span><br><span class="line">2306            startAppShortcutOrInfoActivity(v);</span><br><span class="line">2307        &#125; else if (tag instanceof LauncherAppWidgetInfo) &#123;</span><br><span class="line">2308            if (v instanceof PendingAppWidgetHostView) &#123;</span><br><span class="line">2309                onClickPendingWidget((PendingAppWidgetHostView) v);</span><br><span class="line">2310            &#125;</span><br><span class="line">2311        &#125;</span><br><span class="line">2312    &#125;</span><br></pre></td></tr></table></figure>
<p>onClick事件中，判断当前点击的是一个快捷键图标，然后就调用onClickAppShortcut();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">2420    protected void onClickAppShortcut(final View v) &#123;</span><br><span class="line">2421        if (LOGD) Log.d(TAG, &quot;onClickAppShortcut&quot;);</span><br><span class="line">2422        Object tag = v.getTag();</span><br><span class="line">2423        if (!(tag instanceof ShortcutInfo)) &#123;</span><br><span class="line">2424            throw new IllegalArgumentException(&quot;Input must be a Shortcut&quot;);</span><br><span class="line">2425        &#125;</span><br><span class="line">2426</span><br><span class="line">2427        // Open shortcut</span><br><span class="line">2428        final ShortcutInfo shortcut = (ShortcutInfo) tag;</span><br><span class="line">2429</span><br><span class="line">2430        if (shortcut.isDisabled != 0) &#123;</span><br><span class="line">2431            if ((shortcut.isDisabled &amp;</span><br><span class="line">2432                    ~ShortcutInfo.FLAG_DISABLED_SUSPENDED &amp;</span><br><span class="line">2433                    ~ShortcutInfo.FLAG_DISABLED_QUIET_USER) == 0) &#123;</span><br><span class="line">2434                // If the app is only disabled because of the above flags, launch activity anyway.</span><br><span class="line">2435                // Framework will tell the user why the app is suspended.</span><br><span class="line">2436            &#125; else &#123;</span><br><span class="line">2437                if (!TextUtils.isEmpty(shortcut.disabledMessage)) &#123;</span><br><span class="line">2438                    // Use a message specific to this shortcut, if it has one.</span><br><span class="line">2439                    Toast.makeText(this, shortcut.disabledMessage, Toast.LENGTH_SHORT).show();</span><br><span class="line">2440                    return;</span><br><span class="line">2441                &#125;</span><br><span class="line">2442                // Otherwise just use a generic error message.</span><br><span class="line">2443                int error = R.string.activity_not_available;</span><br><span class="line">2444                if ((shortcut.isDisabled &amp; ShortcutInfo.FLAG_DISABLED_SAFEMODE) != 0) &#123;</span><br><span class="line">2445                    error = R.string.safemode_shortcut_error;</span><br><span class="line">2446                &#125; else if ((shortcut.isDisabled &amp; ShortcutInfo.FLAG_DISABLED_BY_PUBLISHER) != 0 ||</span><br><span class="line">2447                        (shortcut.isDisabled &amp; ShortcutInfo.FLAG_DISABLED_LOCKED_USER) != 0) &#123;</span><br><span class="line">2448                    error = R.string.shortcut_not_available;</span><br><span class="line">2449                &#125;</span><br><span class="line">2450                Toast.makeText(this, error, Toast.LENGTH_SHORT).show();</span><br><span class="line">2451                return;</span><br><span class="line">2452            &#125;</span><br><span class="line">2453        &#125;</span><br><span class="line">2454</span><br><span class="line">2455        // Check for abandoned promise</span><br><span class="line">2456        if ((v instanceof BubbleTextView) &amp;&amp; shortcut.isPromise()) &#123;</span><br><span class="line">2457            String packageName = shortcut.intent.getComponent() != null ?</span><br><span class="line">2458                    shortcut.intent.getComponent().getPackageName() : shortcut.intent.getPackage();</span><br><span class="line">2459            if (!TextUtils.isEmpty(packageName)) &#123;</span><br><span class="line">2460                onClickPendingAppItem(v, packageName,</span><br><span class="line">2461                        shortcut.hasStatusFlag(ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE));</span><br><span class="line">2462                return;</span><br><span class="line">2463            &#125;</span><br><span class="line">2464        &#125;</span><br><span class="line">2465</span><br><span class="line">2466        // Start activities</span><br><span class="line">2467        startAppShortcutOrInfoActivity(v);</span><br><span class="line">2468    &#125;</span><br></pre></td></tr></table></figure>
<p>onClicAppShortcut()在最后将直接调用startAppShortcutOrInfoActivity()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2470    private void startAppShortcutOrInfoActivity(View v) &#123;</span><br><span class="line">2471        ItemInfo item = (ItemInfo) v.getTag();</span><br><span class="line">2472        Intent intent = item.getIntent();</span><br><span class="line">2473        if (intent == null) &#123;</span><br><span class="line">2474            throw new IllegalArgumentException(&quot;Input must have a valid intent&quot;);</span><br><span class="line">2475        &#125;</span><br><span class="line">2476        boolean success = startActivitySafely(v, intent, item);</span><br><span class="line">2477        getUserEventDispatcher().logAppLaunch(v, intent); // TODO for discovered apps b/35802115</span><br><span class="line">2478</span><br><span class="line">2479        if (success &amp;&amp; v instanceof BubbleTextView) &#123;</span><br><span class="line">2480            mWaitingForResume = (BubbleTextView) v;</span><br><span class="line">2481            mWaitingForResume.setStayPressed(true);</span><br><span class="line">2482        &#125;</span><br><span class="line">2483    &#125;</span><br></pre></td></tr></table></figure>
<p>startAppShortcutOrInfoActivity() 中又将调用startActivitySafely()</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487328783787.jpg" alt=""></p>
<p>最终，我们在startActivitySafely()找到了startActivity()。这个startActivity就是Activity中的那个startActivity()。所以接下来的调用过程和Activity启动过程(一)中基本一致，这里给出主要调用方法，具体说明可参考Activity启动过程(一)。</p>
<p>activity.startActivity<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487331415014.jpg" alt=""></p>
<p>activity.startActivityForResult<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487331579468.jpg" alt=""></p>
<p>Instrumentation.execStartActivity<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487331776712.jpg" alt=""></p>
<p>AMS.startActivity<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487332621449.jpg" alt=""></p>
<p>ActivityStarter.startActivityMayWait<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487333065171.jpg" alt=""></p>
<p>ActivityStarter.startActivityLocked<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487333508688.jpg" alt=""></p>
<p>ActivityStarter.startActivity<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487333889767.jpg" alt=""></p>
<p>ActivityStarter.startActivity<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487334182969.jpg" alt=""></p>
<p>ActivityStarter.startActivityUnchecked</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487334618209.jpg" alt=""></p>
<p>ActivityStackSupervisor.resumeFocusedStackTopActivityLocked</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487335006338.jpg" alt=""></p>
<p>ActivityStack.resumeTopActivityUncheckedLocked<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487335398396.jpg" alt=""></p>
<p>ActivityStack.resumeTopActivityInnerLocked</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487335895726.jpg" alt=""></p>
<p>ActivityStackSupervisor.startSpecificActivityLocked</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487336314547.jpg" alt=""></p>
<p>AMS调用走到这里，基本上和ActivityA启动ActivityB的流程是一样的。<br>但是在startSpecificActivityLocked()中，我们注意到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0</span><br><span class="line">                   || !&quot;android&quot;.equals(r.info.packageName)) &#123;</span><br><span class="line">               // Don&apos;t add this if it is a platform component that is marked</span><br><span class="line">               // to run in multiple processes, because this is actually</span><br><span class="line">               // part of the framework so doesn&apos;t make sense to track as a</span><br><span class="line">               // separate apk in the process.</span><br><span class="line">               app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,</span><br><span class="line">                       mService.mProcessStats);</span><br><span class="line">           &#125;</span><br><span class="line">           realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">           return;</span><br><span class="line">       &#125; catch (RemoteException e) &#123;</span><br><span class="line">           Slog.w(TAG, &quot;Exception when starting activity &quot;</span><br><span class="line">                   + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // If a dead object exception was thrown -- fall through to</span><br><span class="line">       // restart the application.</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里只有在app不为空，且app的线程不为空的情况才会调用<br>realStartActivityLocked()。每个App都有一个自己的进程，而我们这里是通过桌面应用打开的，我们的目标App并未创建自己的进程，这app应该是为空的，所以这里并没有执行realStartActivityLocked()。在此方法中我们还看到末尾有这么一句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">               &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br></pre></td></tr></table></figure>
<p>看这个方法的名称，是不是就是在创建进程呢？点进去看看</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487341623636.jpg" alt=""></p>
<p>这里将主要的操作说明一下，其余代码已经删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,</span><br><span class="line">        boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,</span><br><span class="line">        boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,</span><br><span class="line">        String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123;</span><br><span class="line">    long startTime = SystemClock.elapsedRealtime();</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">   </span><br><span class="line">    // We don&apos;t have to do anything more if:</span><br><span class="line">    // (1) There is an existing application record; and</span><br><span class="line">    // (2) The caller doesn&apos;t think it is dead, OR there is no thread</span><br><span class="line">    //     object attached to it so we know it couldn&apos;t have crashed; and</span><br><span class="line">    // (3) There is a pid assigned to it, so it is either starting or</span><br><span class="line">    //     already running.</span><br><span class="line">    //目标进程已经存在，直接返回</span><br><span class="line">    if (app != null &amp;&amp; app.pid &gt; 0) &#123;</span><br><span class="line">        if ((!knownToBeDead &amp;&amp; !app.killed) || app.thread == null) &#123;</span><br><span class="line">            // We already have the app running, or are waiting for it to</span><br><span class="line">            // come up (we have a pid but not yet its thread), so keep it.</span><br><span class="line">            if (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES, &quot;App already running: &quot; + app);</span><br><span class="line">            // If this is a new package in the process, add the package to the list</span><br><span class="line">            app.addPackage(info.packageName, info.versionCode, mProcessStats);</span><br><span class="line">            checkTime(startTime, &quot;startProcess: done, added package to proc&quot;);</span><br><span class="line">            return app;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String hostingNameStr = hostingName != null</span><br><span class="line">            ? hostingName.flattenToShortString() : null;</span><br><span class="line"></span><br><span class="line">    //目标进程不存在，则创建一个新ProcessRecord</span><br><span class="line">    if (app == null) &#123;</span><br><span class="line">        checkTime(startTime, &quot;startProcess: creating new process record&quot;);</span><br><span class="line">        app = newProcessRecordLocked(info, processName, isolated, isolatedUid);</span><br><span class="line">        if (app == null) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Failed making new process record for &quot;</span><br><span class="line">                    + processName + &quot;/&quot; + info.uid + &quot; isolated=&quot; + isolated);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        app.crashHandler = crashHandler;</span><br><span class="line">        checkTime(startTime, &quot;startProcess: done creating new process record&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    //启动新进程</span><br><span class="line">    startProcessLocked(</span><br><span class="line">            app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);</span><br><span class="line">    return (app.pid != 0) ? app : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里做了三件事<br>1.目标进程已经存在，则直接返回<br>2.目标进程不存在，通过newProcessRecordLocked创建一个ProcessRecord<br>3.启动新进程</p>
<p>在startProcessLocked()中</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487408213932.jpg" alt=""></p>
<p>这里使用Process.start() 来开启一个新进程<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487409350887.jpg" alt=""></p>
<p>ZygoteProcess.start()<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487409699970.jpg" alt=""></p>
<p>ZygoteProcess.startViaZygote方法中做了两件事：</p>
<ol>
<li>配置启动进程的参数</li>
<li>调用下面这个方法<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487410728639.jpg" alt=""></li>
</ol>
<p>我们先来看看openZygoteSocketIfNeeded(abi),这个方法名称已经给出了它的作用：如果有必要则打开Zygote的Socket连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123;</span><br><span class="line">     Preconditions.checkState(Thread.holdsLock(mLock), &quot;ZygoteProcess lock not held&quot;);</span><br><span class="line"></span><br><span class="line">     //未创建连接，这里就会调用ZygoteState.connect()进行连接</span><br><span class="line">     if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             primaryZygoteState = ZygoteState.connect(mSocket);</span><br><span class="line">         &#125; catch (IOException ioe) &#123;</span><br><span class="line">             throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">         return primaryZygoteState;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     //abi的架构可能有32位，64位两种，可以理解为一个主要架构和一个辅助架构。主架构不匹配的时候，会使用辅助架构模式。</span><br><span class="line">     // The primary zygote didn&apos;t match. Try the secondary.</span><br><span class="line">     if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             secondaryZygoteState = ZygoteState.connect(mSecondarySocket);</span><br><span class="line">         &#125; catch (IOException ioe) &#123;</span><br><span class="line">             throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">         return secondaryZygoteState;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>不管使用哪种架构模式，我们第一次进来，肯定是还没有连接的，所以，这个时候会调用ZygoteState.connect()，</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487415981670.jpg" alt=""></p>
<p>根据openZygoteSocketIfNeeded中ZygoteState.connect(mSocket)，这个方法的参数是mSocket，这个是当前Socket需要连接的服务端地址，而这个mSocket又是从何而来？<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487417662487.jpg" alt=""></p>
<p>这是mSocke声明的位置，刚好可以看到这个属性是在ZygoteProcess初始化的时候带过来的。而ZygoteProcess 又是在哪里创建的呢？我们回到Process.start()</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487418866087.jpg" alt=""></p>
<p>在这里使用zygoteProcess实例，而他在Process中是这样声明的<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487419380911.jpg" alt=""></p>
<p>所以这里也是ZygoteProcess的创建位置，其中的两个参数分别是：<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487419808363.jpg" alt=""></p>
<p>看到这里，我们就知道了，ZygoteProcess.connect()连接的是zygote服务器。</p>
<p>看完openZygoteSocketIfNeeded() 我们再回到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote)</span><br></pre></td></tr></table></figure>
<p>zygoteSendArgsAndGetResult()也只是简单地将参数发送给服务器，并接收服务返回的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">private static Process.ProcessStartResult zygoteSendArgsAndGetResult(</span><br><span class="line">          ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span><br><span class="line">          throws ZygoteStartFailedEx &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          // Throw early if any of the arguments are malformed. This means we can</span><br><span class="line">          // avoid writing a partial response to the zygote.</span><br><span class="line">          int sz = args.size();</span><br><span class="line">          for (int i = 0; i &lt; sz; i++) &#123;</span><br><span class="line">              if (args.get(i).indexOf(&apos;\n&apos;) &gt;= 0) &#123;</span><br><span class="line">                  throw new ZygoteStartFailedEx(&quot;embedded newlines not allowed&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          /**</span><br><span class="line">           * See com.android.internal.os.SystemZygoteInit.readArgumentList()</span><br><span class="line">           * Presently the wire format to the zygote process is:</span><br><span class="line">           * a) a count of arguments (argc, in essence)</span><br><span class="line">           * b) a number of newline-separated argument strings equal to count</span><br><span class="line">           *</span><br><span class="line">           * After the zygote process reads these it will write the pid of</span><br><span class="line">           * the child or -1 on failure, followed by boolean to</span><br><span class="line">           * indicate whether a wrapper process was used.</span><br><span class="line">           */</span><br><span class="line">          final BufferedWriter writer = zygoteState.writer;</span><br><span class="line">          final DataInputStream inputStream = zygoteState.inputStream;</span><br><span class="line"></span><br><span class="line">          writer.write(Integer.toString(args.size()));</span><br><span class="line">          writer.newLine();</span><br><span class="line"></span><br><span class="line">          for (int i = 0; i &lt; sz; i++) &#123;</span><br><span class="line">              String arg = args.get(i);</span><br><span class="line">              writer.write(arg);</span><br><span class="line">              writer.newLine();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          writer.flush();</span><br><span class="line"></span><br><span class="line">          // Should there be a timeout on this?</span><br><span class="line">          Process.ProcessStartResult result = new Process.ProcessStartResult();</span><br><span class="line"></span><br><span class="line">          // Always read the entire result from the input stream to avoid leaving</span><br><span class="line">          // bytes in the stream for future process starts to accidentally stumble</span><br><span class="line">          // upon.</span><br><span class="line">          result.pid = inputStream.readInt();</span><br><span class="line">          result.usingWrapper = inputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">          if (result.pid &lt; 0) &#123;</span><br><span class="line">              throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          return result;</span><br><span class="line">      &#125; catch (IOException ex) &#123;</span><br><span class="line">          zygoteState.close();</span><br><span class="line">          throw new ZygoteStartFailedEx(ex);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结：</strong><br>1.Launcher中的点击事件开始startActivity()<br>2.ActivityStackSupervisor.startSpecificActivityLocked() 中判断进程为空，开始创建进程<br>3.AMS.startProcessLocked –&gt; Process.start–&gt;ZygoteProcess.start–&gt;ZygoteProcess.startViaZygote</p>
<p>ZygoteProcess.startViaZygote方法主要做三件事：</p>
<ul>
<li>构建需要发送给服务器的相关参数列表，这是ArrayList</li>
<li>连接系统服务端</li>
<li>将第一点中的参数发送给服务端</li>
</ul>
<p><br><br>在上一个小结中，我们反复说道，连接服务端，那这个服务端又是什么呢？这部分知识与系统的启动过程有关，不过没有关系，在这个章节中我们大概了解这部分知识就好了。</p>
<p>读者需要知道的是:系统启动之后会调用ZygoteInit.main()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//1.注册Socket服务，提供给客户端连接</span><br><span class="line">zygoteServer.registerServerSocket(socketName);</span><br><span class="line">// In some configurations, we avoid preloading resources and classes eagerly.</span><br><span class="line">// In such cases, we will preload things prior to our first fork.</span><br><span class="line">if (!enableLazyPreload) &#123;</span><br><span class="line">    //2.预加载</span><br><span class="line">    preload(bootTimingsTraceLog);</span><br><span class="line">   </span><br><span class="line">&#125; else &#123;</span><br><span class="line">    Zygote.resetNicePriority();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//3.启动服务</span><br><span class="line">if (startSystemServer) &#123;</span><br><span class="line">    startSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log.i(TAG, &quot;Accepting command socket connections&quot;);</span><br><span class="line">//4.开启socket的轮询</span><br><span class="line">zygoteServer.runSelectLoop(abiList);</span><br></pre></td></tr></table></figure>
<p>ZygoteInit.main主要做了四件事</p>
<ul>
<li>注册Socket服务，提供给客户端连接</li>
<li>预加载</li>
<li>启动系统服务</li>
<li>zygoteServer.runSelectLoop</li>
</ul>
<p>其中注册服务就是创建一个ServerSocket<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487437888305.jpg" alt=""></p>
<p>zygoteServer.runSelectLoop 则是调用zygote进程的select loop，用来接收客户端发起的连接请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void runSelectLoop(String abiList) throws Zygote.MethodAndArgsCaller &#123;</span><br><span class="line">       ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">       ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">       fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">       peers.add(null);</span><br><span class="line"></span><br><span class="line">       while (true) &#123;</span><br><span class="line">           StructPollfd[] pollFds = new StructPollfd[fds.size()];</span><br><span class="line">           for (int i = 0; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">               pollFds[i] = new StructPollfd();</span><br><span class="line">               pollFds[i].fd = fds.get(i);</span><br><span class="line">               pollFds[i].events = (short) POLLIN;</span><br><span class="line">           &#125;</span><br><span class="line">           try &#123;</span><br><span class="line">               //这里一直在轮询，等待这客户端的连接</span><br><span class="line">               Os.poll(pollFds, -1);</span><br><span class="line">           &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">               throw new RuntimeException(&quot;poll failed&quot;, ex);</span><br><span class="line">           &#125;</span><br><span class="line">           for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">               if ((pollFds[i].revents &amp; POLLIN) == 0) &#123;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">               if (i == 0) &#123;</span><br><span class="line">                   //收到新的连接请求</span><br><span class="line">                   ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                   peers.add(newPeer);</span><br><span class="line">                   fds.add(newPeer.getFileDesciptor());</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   //连接成功之后的数据处理</span><br><span class="line">                   boolean done = peers.get(i).runOnce(this);</span><br><span class="line">                   if (done) &#123;</span><br><span class="line">                       peers.remove(i);</span><br><span class="line">                       fds.remove(i);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>收到连接请求之后，会先创建一个ZygoteConnect,然后调用runOnce。<br>在runOnce中有这几块代码<br>1.获取客户端发送过来的参数,并封装到Arguments，这里只截取部分头部代码。<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487441971363.jpg" alt=""></p>
<p>2.调用Zygote.forkAndSpecialize 从而fork出一个进程<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487442376188.jpg" alt=""></p>
<p>3.处理子进程<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487447463552.jpg" alt=""></p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487448561992.jpg" alt=""><br>在子进程中又调用了ZygoteInit.zygoteInit()<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487448847706.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);</span><br></pre></td></tr></table></figure>
<p>RuntimeInit.applicationInit<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487449875265.jpg" alt=""></p>
<p>RuntimeInit.invokeStaticMain</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)</span><br><span class="line">         throws Zygote.MethodAndArgsCaller &#123;</span><br><span class="line">     Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">     try &#123;</span><br><span class="line">         cl = Class.forName(className, true, classLoader);</span><br><span class="line">     &#125; catch (ClassNotFoundException ex) &#123;</span><br><span class="line">         throw new RuntimeException(</span><br><span class="line">                 &quot;Missing class when invoking static main &quot; + className,</span><br><span class="line">                 ex);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Method m;</span><br><span class="line">     try &#123;</span><br><span class="line">         m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</span><br><span class="line">     &#125; catch (NoSuchMethodException ex) &#123;</span><br><span class="line">         throw new RuntimeException(</span><br><span class="line">                 &quot;Missing static main on &quot; + className, ex);</span><br><span class="line">     &#125; catch (SecurityException ex) &#123;</span><br><span class="line">         throw new RuntimeException(</span><br><span class="line">                 &quot;Problem getting static main on &quot; + className, ex);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     int modifiers = m.getModifiers();</span><br><span class="line">     if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">         throw new RuntimeException(</span><br><span class="line">                 &quot;Main method is not public and static on &quot; + className);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     /*</span><br><span class="line">      * This throw gets caught in ZygoteInit.main(), which responds</span><br><span class="line">      * by invoking the exception&apos;s run() method. This arrangement</span><br><span class="line">      * clears up all the stack frames that were required in setting</span><br><span class="line">      * up the process.</span><br><span class="line">      */</span><br><span class="line">     throw new Zygote.MethodAndArgsCaller(m, argv);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>RuntimeInit.invokeStaticMain 通过classname找到目标Class，并通过反射找到目标Class的启动方法main()，最后将方法和参数都封装到Zygote.MethodAndArgsCaller对象中，并抛出异常。<br>而这里抛出的异常最终在ZygoteInit.main中被捕获<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487453049937.jpg" alt=""><br>异常被捕获之后，直接执行了Zygote.MethodAndArgsCaller.run()<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487454144295.jpg" alt=""></p>
<p>这里的run方法也很简单，直接使用反射，调用我们刚才找到的main方法。</p>
<p>那么问题来了，我们找了半天的main方法，并且调用了，但是这个main方法是谁的呢？</p>
<p>我们回到RuntimeInit.applicationInit()<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487456127785.jpg" alt=""></p>
<p>反射调用静态的main方法，传入的是args.startClass字符串，这个字符在new Arguments(argv)中构建。<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487457114590.jpg" alt=""></p>
<p>解析参数的过程，可以看到，startClass是客户端传递过来的最后一个参数。我们回到客户端发送参数的位置往回找，<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487460737751.jpg" alt=""></p>
<p>我们看到processClass在Process.start中就作为参数传递进来了。那么，再往回看看。<br>ActivityManagerService.startProcessLocked()，entryPoint就是我们带过去的参数processClass<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487461541081.jpg" alt=""></p>
<p>ActivityManagerService.startProcessLocked()<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487461789309.jpg" alt=""></p>
<p>这的entryPoint是null，所以在上个代码片段中，我们就会执行<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487463163879.jpg" alt=""><br>那么，我们需要调用的目标类就可以确定了：android.app.ActivityThread，那么接下来就是直接调用ActivithThread.main()了。</p>
<blockquote>
<p>在invokeStaticMain()中为什么使用抛异常的方式来处理，而不是直接调用MethodAndArgsCaller.run 呢？<br>抛出异常再捕获，有个好处:可以清空之前的所有数据，保留一个较为干净的进程.</p>
</blockquote>
<p><strong>小结：</strong></p>
<p>看到这里，我们已经知道了AMS发送消息给服务端之后，服务端所做的处理。主要分为三部分</p>
<ol>
<li>在Zygote进程中，接收客户端的连接并创建了一个ZygoteConnect；</li>
<li>然后ZygoteConnect.run()中获取参数，fork出子进程；</li>
<li>在子进程中处理客户端传递过来参数，这里就是找到ActivityThread, 并调用其静态main方法。</li>
</ol>
<p><br><br>通过上个小结，我们已经fork出一个子进程，且子进程调用了ActivityThread.main()，那么我们就继续看看ActivityThread.main()又有哪些操作好了。</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487480086771.jpg" alt=""></p>
<p>首先在1中创建了一个消息队列，并在3中开始轮询消息队列。消息队列创建之后，2中就创建了一个ActivityThread并调用了ActivityThread.attach()<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487486401757.jpg" alt=""></p>
<p>attach中获取IActivityManager,并调用IActivityManger.attachApplication()</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487486926251.jpg" alt=""></p>
<p>ActivityMangerService.attachApplication<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487487617244.jpg" alt=""></p>
<p>attachApplicationLocked将回调Thread.bindApplication()<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487488070786.jpg" alt=""></p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487488269697.jpg" alt=""></p>
<p>handleBindApplication 主要做三件事情</p>
<ol>
<li><p>创建Instrumentation对象<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487493632458.jpg" alt=""></p>
</li>
<li><p>创建Application，并绑定<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487490125298.jpg" alt=""></p>
</li>
<li><p>安装ContentProviders<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487491825259.jpg" alt=""></p>
</li>
</ol>
<p>installContentProviders是ContentProviders的创建过程，这里暂不细说。</p>
<p>看完Application的创建和绑定，我们回到<br>AMS.attachApplicationLocked,在bindApplication之后我们还看到了这个方法<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487494666943.jpg" alt=""></p>
<p>ActivityStackSupervisor.attachApplicationLocked<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487495201782.jpg" alt=""></p>
<p>这里主要是遍历当前进程中的Activity栈，并通过realStartActivityLocked启动栈顶Activity。这个栈顶Activity就是最初点击桌面快捷键时，需要打开的Activity,也就是目标APP的启动页。<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487497072768.jpg" alt=""></p>
<p>realStartActivityLocked 中调用scheduleLaunchActivity，从而将AMS的调用过程回转给了ActivityThread。</p>
<p>之后Activity的启动过程，已经在Activity启动过程(一)中有详细的说明，这里不再赘述。</p>
<p><strong>小结:</strong><br>ActivityThread.main中完成两件事</p>
<ul>
<li>创建消息队列并不断轮询</li>
<li>调用ActivityThread.attach<ul>
<li>bindApplication</li>
<li>ActivityStackSupervisor.attachApplicationLocked()–&gt;realStartActivityLocked()</li>
</ul>
</li>
</ul>
<p>以上：当我们点击桌面快捷键启动一个App时，系统其实为我们做了这些事情</p>
<ol>
<li><p>桌面应用:调用startActivity</p>
</li>
<li><p>AMS准备打开Activity时发现目标APP未创建进程,与服务端创建连接，发送相关参数</p>
</li>
<li><p>zygote进程作为服务端</p>
<p> 2.1 服务器接收连接和参数<br> 2.2 fork子进程<br> 2.3 子进程中调用ActivityThread.main</p>
</li>
<li><p>ActivityThread.main<br> 4.1 创建消息队列并循环<br> 4.2 ActivityThread.attach(),在attach中将调用bindApplication()和ActivityStackSupervisor.attachApplicationLocked()–&gt;ActivityStackSupervisor.realStartActivityLocked</p>
</li>
<li><p>打开activity</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zmylls.github.io/2019/01/28/Activity 启动过程(一)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Asher.zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Zmy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/28/Activity 启动过程(一)/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-28T19:57:17+08:00">
                2019-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Activity-启动过程-一"><a href="#Activity-启动过程-一" class="headerlink" title="Activity 启动过程(一)"></a>Activity 启动过程(一)</h1><p>这里讲的是一个Activity启动另一个Activity的过程。<br>首先我们在activity.startActivity(),点进去我们可以看到如下</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486772761818.jpg" alt="logo"></p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486772908727.jpg" alt=""></p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486773071393.jpg" alt=""></p>
<p>在Activity中最终都是调用startActivityForResult(),在这个方法中又调用mInstrumentation.execStartActivity()。</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486776690721.jpg" alt=""></p>
<p>在这个方法里，调用了ActivityManager.getService().startActivity(),我们先来看看getService()会返回什么对象。</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486778672837.jpg" alt=""></p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486778856899.jpg" alt=""></p>
<p>getService() 只是调用了IActivityManagerSingleton.get()。而IActivityManagerSingleton则是一个Singleton的实例。<br>Singleton的代码如下：<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486779802660.jpg" alt=""></p>
<p>从Singleton可以看到，IActivityManagerSingleton.get()在第一次的时候会调用create()，而这个IActivityManagerSingleton 的create() 正是的前面看到的这个方法：<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486778856899.jpg" alt=""></p>
<p>这里将通过IActivityManager.Stub.asInterface(b)返回一个IActivityManager对象实例。因此IActivityManagerSingleton.get()也将返回一个IActivityManager对象实例。</p>
<p>因为笔者这里看的是26的源码，26中增加了IActivityManager.aidl文件，这部分代码需要在<a href="http://androidxref.com/8.0.0_r4/xref/frameworks/base/core/java/android/app/IActivityManager.aidl" target="_blank" rel="noopener">AndroidXref中的IActivityManager.aidl</a>中查看，部分定义如下：<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486787413207.jpg" alt=""></p>
<p>我们在使用aidl的时候，AS都会帮我们生成一个Stub和本地的代理对象。IActivityManager也会对应生成一个IActivityManager.Stub类，且它有个子类为ActivityManagerService<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486794120831.jpg" alt=""></p>
<p>而我们之前IActivityManagerSingleton.get()取得的就是一个ActivityManagerService或者是ActivityManagerService的一个代理。</p>
<blockquote>
<p>注：这一部分具体参考下Binder的定义及使用。另外我还没有说明如何能找到ActivityManagerService，这一部分都是参考其他文章所得，具体如何通过IActivityManager.aidl定位到这个类的，还需要再捋一捋。</p>
</blockquote>
<p>现在我们回到Instrumentation<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486797142078.jpg" alt=""></p>
<p>ActivityManager.getService() 即返回一个ActivityManagerService或者其代理对象。所以这里最终就是调用了ActivityManagerService.startActivity()<br><br><br><strong>小结一：</strong><br>这里使用简单的时序图来说明方法的调用过程。这里的AMS即时ActivityManagerService的缩写，之后读将采用这个缩写来代码ActivityManagerService.</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486811350826.jpg" alt=""></p>
<p><br><br><br><br>我们通过前面方法的查找，已经知道启动一个Activity之后，最终会调用系统的ActivityManagerService.startActivity(),接下来我们就看看这个方法又做了哪些操作。</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486816418828.jpg" alt=""></p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486816757171.jpg" alt=""></p>
<p>这里最后调用了mActivityStarter.startActivityMayWait(),这样就将调用过程转交给了ActivityStarter类。</p>
<p>在这个方法中可以看到下面这一句话，这主要是在收集目标Activity的信息，将信息存储在ActivityInfo中。<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486819210213.jpg" alt=""></p>
<p>之后又调用了本类中的startActivityLocked()，如下：<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486819855403.jpg" alt=""></p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486820892862.jpg" alt=""></p>
<p>在这里校验了调用方法的原因。然后调用了ActivityStarter中的startActivity()。<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486822330110.jpg" alt=""></p>
<p>在这个方法中主要做了一些校验，包括：权限校验、component校验、目标activity信息校验等。同时创建一个ActivityRecord对象，用来存放这些校验过后的数据：<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486827320180.jpg" alt=""></p>
<p>然后继续调用下一个startActivity()<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486827457382.jpg" alt=""></p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486827875618.jpg" alt=""></p>
<p>在这个startActivity()中将调用ActivityStarter的startActivityUnchecked()，startActivityUnchecked()方法挺长，主要是activity栈的处理，比如是否在栈顶、是否需要新建一个栈。在这个方法中将调用mSupervisor.resumeFocusedStackTopActivityLocked().</p>
<p>这是怎么回事呢？<br>首先我们回到这里<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486827457382.jpg" alt=""></p>
<p>我们可以看到第六个参数设置为true，而这个true将一直跟着我们的方法传递下去，直到startActivityUnchecked调用了setInitialState()之后将这个true赋给了ActivityStarter中的mDoResume属性。</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486841490088.jpg" alt=""><br>因此，最后我们将走入这个代码块。<br>这里两段英文，尝试着翻译一下：</p>
<blockquote>
<p>If the activity is not focusable, we can’t resume it, but still would like to make sure it becomes visible as it starts (this will also trigger entry animation). An example of this are PIP activities.Also, we don’t want to resume activities in a task that currently has an overlay as the starting activity just needs to be in the visible paused state until the over is removed.<br>如果Activity不可聚焦，就不能重启它，不过我们仍可保证当它启动的时候是可见的。比如PIP的活动。我们不想重启一个可覆盖任务中的activities，因为开始的活动只需要处于可见的暂停状态，直到移除覆盖。</p>
<p>If the target stack was not previously focusable (previous top running activity on that stack was not visible) then any prior calls to move the stack to the will not update the focused stack.  If starting the new activity now allows the task stack to be focusable, then ensure that we now update the focused stack accordingly.<br>如果目标栈之前不可获取焦点（之前顶层的activity不可见），那么将该栈移动到不会更新的焦点栈中。如果现在是新建一个activity，就允许任务栈是可以获取焦点的，然后确保我们现在在更新相关的焦点栈。</p>
<p>(英文太烂，自己都不理解翻译出来的是什么👻 -_-! )</p>
</blockquote>
<p>根据上面两段注释，我们可以认为这里会调用mSupervisor.resumeFocusedStackTopActivityLocked(),这里的mSuperVisor对应的是ActivityStackSupervisor类。接着继续看下去：</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486861634048.jpg" alt=""></p>
<p>我们在之前已经构造出一个ActivityRecord,所以这里会调用mFocusedStack.resumeTopActivityUncheckedLocked().其中mFocuseStack是ActivityStack的一个实例。<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486862880125.jpg" alt=""></p>
<p>在resumeTopActivityInnerLocked()中将调用<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486865513070.jpg" alt=""></p>
<p>这里又将调用过程交给了ActivityStackSupervisor。</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486866052523.jpg" alt=""></p>
<p>这里将调用realStartActivityLocked()</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486866431895.jpg" alt=""></p>
<p>realStartActivityLocked()又调用了app.thread.scheduleLaunchActivity()，这个app.thread就是客户端调用系统AMS时传递过来的ActivityThread对象，因此这里就是在调用客户端的ActivityThread.scheduleLaunchActivity()</p>
<blockquote>
<p>这里客户端指的就是当前的app进程，而服务端指的就是Android系统服务进程,可参看SystemServer类。之后也将会继续沿用客户端和服务端这样的概念。</p>
</blockquote>
<p><strong>小结二：</strong><br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15486879854107.jpg" alt=""></p>
<p><br><br>前面一个小结结束之后，我们已经将调用过程从系统服务回调到了客户端，那么我们现在就接着看客户端做了哪些操作。</p>
<p>首先我们来看看ActivityThread.scheduleLaunchActivity()</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487254546912.jpg" alt=""></p>
<p>这个方法中主要是将AMS传递过来的参数封装到ActivityClientRecord的实例中，并将这个ActivityClientRecord发送到消息队列，等待消息的处理。</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487255560742.jpg" alt=""></p>
<p>查看sendMessage()方法，可以确定消息是通过mH来发送的，我们来看看mH的定义。<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487256540735.jpg" alt=""></p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487256701988.jpg" alt=""></p>
<p>有定义内容可以知道mH就是一个Handler。<br>由上文我们知道ActivityThread.scheduleLaunchActivity()中发出的是一个LAUNCH_ACTIVITY消息，我们看看接收处的代码。</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487257764437.jpg" alt=""></p>
<p>这里直接调用handleLaunchActivity() 来处理ActivityClientRecord ，继续查看这个方法<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487258434872.jpg" alt=""></p>
<p>在这个方法中，有两个明显的方法名称，一个performLaunchActivity()，一个是handleResumeActivity()。我们先来看看performLaunchActivity()，这个方法比较长，内容也比较多，我们细分几段来查看。</p>
<p>第一段：<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487261316606.jpg" alt=""></p>
<p>这里主要通过AMS传递过来的ActivityClientRecord进行包信息和ComponentName信息的构建。同时这个有个createBaseContextForActivity()<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487263361245.jpg" alt=""></p>
<p>在这个方法中将创建ContextImpl对象。<br>由此可到这一段主要是创建Activity上下文信息。</p>
<p>第二段：<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487264746227.jpg" alt=""></p>
<p>mInstrumentation.newActivity() 如下：<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487266082203.jpg" alt=""></p>
<p>这里通过反射创建了一个Activity实例。</p>
<p>第三段：</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487267001597.jpg" alt=""></p>
<p>这里只是创建一个Applicatio的实例。<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487269199465.jpg" alt=""></p>
<p>代码1判断，application对象已经创建，则直接返回，这也是为什么同一个进程中，我们的application可以保持为一个单例的原因。<br>代码2则是创建了Application所需的上下文ContextImpl实例，同时调用Instrumentation.newApplication()创建了Application实例。<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487270600482.jpg" alt=""></p>
<p>这里我们可以看到，Application也是通过反射来创建的。创建完成之后立即调用了Application.attach(),attach()中将继续调用attachBaseContext()</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487272158696.jpg" alt=""></p>
<p>回到入口方法makeApplication(),继续往下看。<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487273174539.jpg" alt=""></p>
<p>instrumentation.callApplicationOnCreate(app)</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487273771032.jpg" alt=""></p>
<p>到这里，我们就将application的创建过程也看完了。所以第四段只是创建Application实例.</p>
<p>第四段</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487275709948.jpg" alt=""></p>
<p>代码1就是调用了Activity.attach()。Activity.attach() 主要是创建Window信息。<br>代码2点进去，其实就在调用Activity.performCreate(),而performCreate()将调用onCreate()。<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487276231544.jpg" alt=""></p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487277510425.jpg" alt=""></p>
<p><strong>小小结：</strong><br>第一段：创建Activity上下文</p>
<p>第二段：利用反射创建Activity</p>
<p>第三段：获取Application实例。如果已经存在则直接方法，如果未创建则利用反射创建Application实例，并调它的attach，onCreate等方法</p>
<p>第四段：调用Activity的attach和onCreate。值得一提的是attach() 中将创建window信息。</p>
<p>看到这里，我们基本已经明白了一个新Activity的创建过程，但是它是怎么作为一个界面显示出来的呢？这部分内容和WindowManagerService(简称WMS)相关，我们暂时先不讨论。以往我们常说，Activity在onResume之后才是可见的。那我们接下来就来找找这个说法的答案。</p>
<p>上文中的handleLaunchActivity(),除了performLaunchActivity(),我们还提到了handleResumeActivity(),接下来就点击去看看，这个方法又做了哪些操作。</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487286148072.jpg" alt=""></p>
<p>handleResumeActivity() 调用了actiivty.performResume()<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487286377997.jpg" alt=""></p>
<p>在performResume()中，注意红框内容，这里分别调用了performRestart() 和mInstrumentation.callActivityOnResume() 分别对应的Activity.onStart()、Activity.reStart()和Activity.onResume().具体调用过程比较简单，这里就不再描述了。<br><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487289974956.jpg" alt=""></p>
<p>看到这里，我们也看完了activity.onResume的调用过程。但并没有找到到界面显示时机。我们回到handleResumeActivity()并继续往下看。</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487296112064.jpg" alt=""></p>
<p>这里主要理解下注释：如果当前Activity的window未添加到WindowManager，这个activity就不可以关闭或打开新的activity。</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487298313638.jpg" alt=""></p>
<p>这里先是将decor设置为不可见，然后将decor添加到WindowManager中。</p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487299092909.jpg" alt=""></p>
<p><img src="/2019/01/28/Activity 启动过程(一)/media/15486766374750/15487299393419.jpg" alt=""></p>
<p>这里又调用了一次mDecor.setVisibility(View.VISIBLE)将decorview设置为可见了。</p>
<p>看到这，我们也找到了Activity为什么是在onResume之后才是可见的。</p>
<p><strong>小结：</strong></p>
<ol>
<li><p>scheduleLaunchActivity()之后，通过Handler.sendMessage()将线程切换回主线程，同时在主线程中并调用handleLaunchActivity()。而handleLaunchActivity()方法中又将调用performLaunchActivity()和handleResumeActivity()。</p>
<p> 这个小点即是scheduleLaunchActivity之后的调用过程，是比较简单的，这里就不再绘制时序图了。</p>
</li>
<li><p>performLaunchActivity() 主要分为四个片段<br>2.1 创建Activity上下文ContextImpl<br>2.2 利用反射创建Activity<br>2.3 获取Application实例。如果已经存在则直接返回，如果未创建则利用反射创建Application实例，并调它的attach，onCreate等方法<br>2.4 调用Activity的attach和onCreate。值得一提的是attach() 中将创建window信息。</p>
</li>
<li><p>handleResumeActivity<br>3.1 调用onstart，onReStart，onResume等方法<br>3.2 将decorview设置为不可见，然后将view添加到windowmanager<br>3.3 将decorview设置为可见</p>
</li>
</ol>
<p><br><br>以上，一个Activity启动另一个Activity的过程，我们就算是看完了。这里主要将其分为三个步骤。</p>
<ol>
<li>客户端Activity通过Instrumentation获取AMS，并代用AMS的startActivity()</li>
<li>AMS中完成权限校验、Activity栈处理、目标Activity信息构建，然后通过ActivityThread.scheduleLaunchActivity回调到客户端</li>
<li>客户端通过handler将线程切换到主线程，然后在handleLaunchActivity() 中完成activity的创建和显示。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Asher.zhang</p>
              <p class="site-description motion-element" itemprop="description">Asher.zhang's blogs.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Asher.zhang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
