<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Activity启动过程(二)上一篇文章，我们是通过一个Activity启动另一个Activity来说明Activity的启动过程。而这篇文章，笔者将从启动一个APP的角度来说明一个Activity的启动过程。 通常我们是通过点击手机桌面的快捷入口来启动一个APP的。手机桌面也是一个APP，这个APP的源代码就是Launcher3，它在/packages/apps/Launcher3/目录下。我们">
<meta property="og:type" content="article">
<meta property="og:title" content="耀舞夕阳">
<meta property="og:url" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/index.html">
<meta property="og:site_name" content="耀舞夕阳">
<meta property="og:description" content="Activity启动过程(二)上一篇文章，我们是通过一个Activity启动另一个Activity来说明Activity的启动过程。而这篇文章，笔者将从启动一个APP的角度来说明一个Activity的启动过程。 通常我们是通过点击手机桌面的快捷入口来启动一个APP的。手机桌面也是一个APP，这个APP的源代码就是Launcher3，它在/packages/apps/Launcher3/目录下。我们">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487321554898.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487322574407.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487328783787.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487331415014.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487331579468.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487331776712.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487332621449.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487333065171.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487333508688.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487333889767.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487334182969.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487334618209.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487335006338.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487335398396.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487335895726.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487336314547.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487341623636.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487408213932.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487409350887.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487409699970.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487410728639.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487415981670.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487417662487.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487418866087.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487419380911.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487419808363.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487437888305.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487441971363.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487442376188.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487447463552.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487448561992.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487448847706.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487449875265.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487453049937.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487454144295.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487456127785.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487457114590.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487460737751.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487461541081.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487461789309.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487463163879.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487480086771.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487486401757.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487486926251.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487487617244.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487488070786.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487488269697.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487493632458.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487490125298.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487491825259.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487494666943.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487495201782.jpg">
<meta property="og:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487497072768.jpg">
<meta property="og:updated_time" content="2019-01-29T15:14:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="耀舞夕阳">
<meta name="twitter:description" content="Activity启动过程(二)上一篇文章，我们是通过一个Activity启动另一个Activity来说明Activity的启动过程。而这篇文章，笔者将从启动一个APP的角度来说明一个Activity的启动过程。 通常我们是通过点击手机桌面的快捷入口来启动一个APP的。手机桌面也是一个APP，这个APP的源代码就是Launcher3，它在/packages/apps/Launcher3/目录下。我们">
<meta name="twitter:image" content="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/media/15487316429786/15487321554898.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/"/>





  <title> | 耀舞夕阳</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">耀舞夕阳</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Light dance and sunset</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="耀舞夕阳">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="耀舞夕阳">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-29T11:14:02+08:00">
                2019-01-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2019-01-29T23:14:51+08:00">
                2019-01-29
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Activity启动过程-二"><a href="#Activity启动过程-二" class="headerlink" title="Activity启动过程(二)"></a>Activity启动过程(二)</h1><p>上一篇文章，我们是通过一个Activity启动另一个Activity来说明Activity的启动过程。而这篇文章，笔者将从启动一个APP的角度来说明一个Activity的启动过程。</p>
<p>通常我们是通过点击手机桌面的快捷入口来启动一个APP的。手机桌面也是一个APP，这个APP的源代码就是<a href="http://androidxref.com/8.0.0_r4/xref/packages/apps/Launcher3/" target="_blank" rel="noopener">Launcher3</a>，它在/packages/apps/Launcher3/目录下。我们可以看到，这其实也就是一个APP的项目结构。</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487321554898.jpg" alt=""></p>
<p>从src目录点击去，找到Launcher.java文件<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487322574407.jpg" alt=""></p>
<p>这个Launcher是继承了一个BaseActivity,所以它也是一个Activivty。Launcher的界面布局、界面显示的信息，我们这里不做讨论。有兴趣的同学可以找下Launcher启动过程的相关文章。</p>
<p>用户在桌面上点击一个快捷键图片就可以打开一个APP，那肯定有个点击事件来触发这个操作，所以我们先来找找Launcher中的点击事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">2262 public void onClick(View v) &#123;</span><br><span class="line">2263        // Make sure that rogue clicks don&apos;t get through while allapps is launching, or after the</span><br><span class="line">2264        // view has detached (it&apos;s possible for this to happen if the view is removed mid touch).</span><br><span class="line">2265        if (v.getWindowToken() == null) &#123;</span><br><span class="line">2266            return;</span><br><span class="line">2267        &#125;</span><br><span class="line">2268</span><br><span class="line">2269        if (!mWorkspace.isFinishedSwitchingState()) &#123;</span><br><span class="line">2270            return;</span><br><span class="line">2271        &#125;</span><br><span class="line">2272</span><br><span class="line">2273        if (v instanceof Workspace) &#123;</span><br><span class="line">2274            if (mWorkspace.isInOverviewMode()) &#123;</span><br><span class="line">2275                getUserEventDispatcher().logActionOnContainer(LauncherLogProto.Action.Type.TOUCH,</span><br><span class="line">2276                        LauncherLogProto.Action.Direction.NONE,</span><br><span class="line">2277                        LauncherLogProto.ContainerType.OVERVIEW, mWorkspace.getCurrentPage());</span><br><span class="line">2278                showWorkspace(true);</span><br><span class="line">2279            &#125;</span><br><span class="line">2280            return;</span><br><span class="line">2281        &#125;</span><br><span class="line">2282</span><br><span class="line">2283        if (v instanceof CellLayout) &#123;</span><br><span class="line">2284            if (mWorkspace.isInOverviewMode()) &#123;</span><br><span class="line">2285                int page = mWorkspace.indexOfChild(v);</span><br><span class="line">2286                getUserEventDispatcher().logActionOnContainer(LauncherLogProto.Action.Type.TOUCH,</span><br><span class="line">2287                        LauncherLogProto.Action.Direction.NONE,</span><br><span class="line">2288                        LauncherLogProto.ContainerType.OVERVIEW, page);</span><br><span class="line">2289                mWorkspace.snapToPageFromOverView(page);</span><br><span class="line">2290                showWorkspace(true);</span><br><span class="line">2291            &#125;</span><br><span class="line">2292            return;</span><br><span class="line">2293        &#125;</span><br><span class="line">2294</span><br><span class="line">2295        Object tag = v.getTag();</span><br><span class="line">2296        if (tag instanceof ShortcutInfo) &#123;</span><br><span class="line">                //找到tag对应一个快捷键</span><br><span class="line">2297            onClickAppShortcut(v);</span><br><span class="line">2298        &#125; else if (tag instanceof FolderInfo) &#123;</span><br><span class="line">2299            if (v instanceof FolderIcon) &#123;</span><br><span class="line">2300                onClickFolderIcon(v);</span><br><span class="line">2301            &#125;</span><br><span class="line">2302        &#125; else if ((FeatureFlags.LAUNCHER3_ALL_APPS_PULL_UP &amp;&amp; v instanceof PageIndicator) ||</span><br><span class="line">2303                (v == mAllAppsButton &amp;&amp; mAllAppsButton != null)) &#123;</span><br><span class="line">2304            onClickAllAppsButton(v);</span><br><span class="line">2305        &#125; else if (tag instanceof AppInfo) &#123;</span><br><span class="line">2306            startAppShortcutOrInfoActivity(v);</span><br><span class="line">2307        &#125; else if (tag instanceof LauncherAppWidgetInfo) &#123;</span><br><span class="line">2308            if (v instanceof PendingAppWidgetHostView) &#123;</span><br><span class="line">2309                onClickPendingWidget((PendingAppWidgetHostView) v);</span><br><span class="line">2310            &#125;</span><br><span class="line">2311        &#125;</span><br><span class="line">2312    &#125;</span><br></pre></td></tr></table></figure>
<p>onClick事件中，判断当前点击的是一个快捷键图标，然后就调用onClickAppShortcut();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">2420    protected void onClickAppShortcut(final View v) &#123;</span><br><span class="line">2421        if (LOGD) Log.d(TAG, &quot;onClickAppShortcut&quot;);</span><br><span class="line">2422        Object tag = v.getTag();</span><br><span class="line">2423        if (!(tag instanceof ShortcutInfo)) &#123;</span><br><span class="line">2424            throw new IllegalArgumentException(&quot;Input must be a Shortcut&quot;);</span><br><span class="line">2425        &#125;</span><br><span class="line">2426</span><br><span class="line">2427        // Open shortcut</span><br><span class="line">2428        final ShortcutInfo shortcut = (ShortcutInfo) tag;</span><br><span class="line">2429</span><br><span class="line">2430        if (shortcut.isDisabled != 0) &#123;</span><br><span class="line">2431            if ((shortcut.isDisabled &amp;</span><br><span class="line">2432                    ~ShortcutInfo.FLAG_DISABLED_SUSPENDED &amp;</span><br><span class="line">2433                    ~ShortcutInfo.FLAG_DISABLED_QUIET_USER) == 0) &#123;</span><br><span class="line">2434                // If the app is only disabled because of the above flags, launch activity anyway.</span><br><span class="line">2435                // Framework will tell the user why the app is suspended.</span><br><span class="line">2436            &#125; else &#123;</span><br><span class="line">2437                if (!TextUtils.isEmpty(shortcut.disabledMessage)) &#123;</span><br><span class="line">2438                    // Use a message specific to this shortcut, if it has one.</span><br><span class="line">2439                    Toast.makeText(this, shortcut.disabledMessage, Toast.LENGTH_SHORT).show();</span><br><span class="line">2440                    return;</span><br><span class="line">2441                &#125;</span><br><span class="line">2442                // Otherwise just use a generic error message.</span><br><span class="line">2443                int error = R.string.activity_not_available;</span><br><span class="line">2444                if ((shortcut.isDisabled &amp; ShortcutInfo.FLAG_DISABLED_SAFEMODE) != 0) &#123;</span><br><span class="line">2445                    error = R.string.safemode_shortcut_error;</span><br><span class="line">2446                &#125; else if ((shortcut.isDisabled &amp; ShortcutInfo.FLAG_DISABLED_BY_PUBLISHER) != 0 ||</span><br><span class="line">2447                        (shortcut.isDisabled &amp; ShortcutInfo.FLAG_DISABLED_LOCKED_USER) != 0) &#123;</span><br><span class="line">2448                    error = R.string.shortcut_not_available;</span><br><span class="line">2449                &#125;</span><br><span class="line">2450                Toast.makeText(this, error, Toast.LENGTH_SHORT).show();</span><br><span class="line">2451                return;</span><br><span class="line">2452            &#125;</span><br><span class="line">2453        &#125;</span><br><span class="line">2454</span><br><span class="line">2455        // Check for abandoned promise</span><br><span class="line">2456        if ((v instanceof BubbleTextView) &amp;&amp; shortcut.isPromise()) &#123;</span><br><span class="line">2457            String packageName = shortcut.intent.getComponent() != null ?</span><br><span class="line">2458                    shortcut.intent.getComponent().getPackageName() : shortcut.intent.getPackage();</span><br><span class="line">2459            if (!TextUtils.isEmpty(packageName)) &#123;</span><br><span class="line">2460                onClickPendingAppItem(v, packageName,</span><br><span class="line">2461                        shortcut.hasStatusFlag(ShortcutInfo.FLAG_INSTALL_SESSION_ACTIVE));</span><br><span class="line">2462                return;</span><br><span class="line">2463            &#125;</span><br><span class="line">2464        &#125;</span><br><span class="line">2465</span><br><span class="line">2466        // Start activities</span><br><span class="line">2467        startAppShortcutOrInfoActivity(v);</span><br><span class="line">2468    &#125;</span><br></pre></td></tr></table></figure>
<p>onClicAppShortcut()在最后将直接调用startAppShortcutOrInfoActivity()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2470    private void startAppShortcutOrInfoActivity(View v) &#123;</span><br><span class="line">2471        ItemInfo item = (ItemInfo) v.getTag();</span><br><span class="line">2472        Intent intent = item.getIntent();</span><br><span class="line">2473        if (intent == null) &#123;</span><br><span class="line">2474            throw new IllegalArgumentException(&quot;Input must have a valid intent&quot;);</span><br><span class="line">2475        &#125;</span><br><span class="line">2476        boolean success = startActivitySafely(v, intent, item);</span><br><span class="line">2477        getUserEventDispatcher().logAppLaunch(v, intent); // TODO for discovered apps b/35802115</span><br><span class="line">2478</span><br><span class="line">2479        if (success &amp;&amp; v instanceof BubbleTextView) &#123;</span><br><span class="line">2480            mWaitingForResume = (BubbleTextView) v;</span><br><span class="line">2481            mWaitingForResume.setStayPressed(true);</span><br><span class="line">2482        &#125;</span><br><span class="line">2483    &#125;</span><br></pre></td></tr></table></figure>
<p>startAppShortcutOrInfoActivity() 中又将调用startActivitySafely()</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487328783787.jpg" alt=""></p>
<p>最终，我们在startActivitySafely()找到了startActivity()。这个startActivity就是Activity中的那个startActivity()。所以接下来的调用过程和Activity启动过程(一)中基本一致，这里给出主要调用方法，具体说明可参考Activity启动过程(一)。</p>
<p>activity.startActivity<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487331415014.jpg" alt=""></p>
<p>activity.startActivityForResult<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487331579468.jpg" alt=""></p>
<p>Instrumentation.execStartActivity<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487331776712.jpg" alt=""></p>
<p>AMS.startActivity<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487332621449.jpg" alt=""></p>
<p>ActivityStarter.startActivityMayWait<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487333065171.jpg" alt=""></p>
<p>ActivityStarter.startActivityLocked<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487333508688.jpg" alt=""></p>
<p>ActivityStarter.startActivity<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487333889767.jpg" alt=""></p>
<p>ActivityStarter.startActivity<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487334182969.jpg" alt=""></p>
<p>ActivityStarter.startActivityUnchecked</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487334618209.jpg" alt=""></p>
<p>ActivityStackSupervisor.resumeFocusedStackTopActivityLocked</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487335006338.jpg" alt=""></p>
<p>ActivityStack.resumeTopActivityUncheckedLocked<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487335398396.jpg" alt=""></p>
<p>ActivityStack.resumeTopActivityInnerLocked</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487335895726.jpg" alt=""></p>
<p>ActivityStackSupervisor.startSpecificActivityLocked</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487336314547.jpg" alt=""></p>
<p>AMS调用走到这里，基本上和ActivityA启动ActivityB的流程是一样的。<br>但是在startSpecificActivityLocked()中，我们注意到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">if (app != null &amp;&amp; app.thread != null) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0</span><br><span class="line">                   || !&quot;android&quot;.equals(r.info.packageName)) &#123;</span><br><span class="line">               // Don&apos;t add this if it is a platform component that is marked</span><br><span class="line">               // to run in multiple processes, because this is actually</span><br><span class="line">               // part of the framework so doesn&apos;t make sense to track as a</span><br><span class="line">               // separate apk in the process.</span><br><span class="line">               app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode,</span><br><span class="line">                       mService.mProcessStats);</span><br><span class="line">           &#125;</span><br><span class="line">           realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">           return;</span><br><span class="line">       &#125; catch (RemoteException e) &#123;</span><br><span class="line">           Slog.w(TAG, &quot;Exception when starting activity &quot;</span><br><span class="line">                   + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // If a dead object exception was thrown -- fall through to</span><br><span class="line">       // restart the application.</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里只有在app不为空，且app的线程不为空的情况才会调用<br>realStartActivityLocked()。每个App都有一个自己的进程，而我们这里是通过桌面应用打开的，我们的目标App并未创建自己的进程，这app应该是为空的，所以这里并没有执行realStartActivityLocked()。在此方法中我们还看到末尾有这么一句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0,</span><br><span class="line">               &quot;activity&quot;, r.intent.getComponent(), false, false, true);</span><br></pre></td></tr></table></figure>
<p>看这个方法的名称，是不是就是在创建进程呢？点进去看看</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487341623636.jpg" alt=""></p>
<p>这里将主要的操作说明一下，其余代码已经删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">final ProcessRecord startProcessLocked(String processName, ApplicationInfo info,</span><br><span class="line">        boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName,</span><br><span class="line">        boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge,</span><br><span class="line">        String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) &#123;</span><br><span class="line">    long startTime = SystemClock.elapsedRealtime();</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">   </span><br><span class="line">    // We don&apos;t have to do anything more if:</span><br><span class="line">    // (1) There is an existing application record; and</span><br><span class="line">    // (2) The caller doesn&apos;t think it is dead, OR there is no thread</span><br><span class="line">    //     object attached to it so we know it couldn&apos;t have crashed; and</span><br><span class="line">    // (3) There is a pid assigned to it, so it is either starting or</span><br><span class="line">    //     already running.</span><br><span class="line">    //目标进程已经存在，直接返回</span><br><span class="line">    if (app != null &amp;&amp; app.pid &gt; 0) &#123;</span><br><span class="line">        if ((!knownToBeDead &amp;&amp; !app.killed) || app.thread == null) &#123;</span><br><span class="line">            // We already have the app running, or are waiting for it to</span><br><span class="line">            // come up (we have a pid but not yet its thread), so keep it.</span><br><span class="line">            if (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES, &quot;App already running: &quot; + app);</span><br><span class="line">            // If this is a new package in the process, add the package to the list</span><br><span class="line">            app.addPackage(info.packageName, info.versionCode, mProcessStats);</span><br><span class="line">            checkTime(startTime, &quot;startProcess: done, added package to proc&quot;);</span><br><span class="line">            return app;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String hostingNameStr = hostingName != null</span><br><span class="line">            ? hostingName.flattenToShortString() : null;</span><br><span class="line"></span><br><span class="line">    //目标进程不存在，则创建一个新ProcessRecord</span><br><span class="line">    if (app == null) &#123;</span><br><span class="line">        checkTime(startTime, &quot;startProcess: creating new process record&quot;);</span><br><span class="line">        app = newProcessRecordLocked(info, processName, isolated, isolatedUid);</span><br><span class="line">        if (app == null) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Failed making new process record for &quot;</span><br><span class="line">                    + processName + &quot;/&quot; + info.uid + &quot; isolated=&quot; + isolated);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        app.crashHandler = crashHandler;</span><br><span class="line">        checkTime(startTime, &quot;startProcess: done creating new process record&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    //启动新进程</span><br><span class="line">    startProcessLocked(</span><br><span class="line">            app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);</span><br><span class="line">    return (app.pid != 0) ? app : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里做了三件事<br>1.目标进程已经存在，则直接返回<br>2.目标进程不存在，通过newProcessRecordLocked创建一个ProcessRecord<br>3.启动新进程</p>
<p>在startProcessLocked()中</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487408213932.jpg" alt=""></p>
<p>这里使用Process.start() 来开启一个新进程<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487409350887.jpg" alt=""></p>
<p>ZygoteProcess.start()<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487409699970.jpg" alt=""></p>
<p>ZygoteProcess.startViaZygote方法中做了两件事：</p>
<ol>
<li>配置启动进程的参数</li>
<li>调用下面这个方法<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487410728639.jpg" alt=""></li>
</ol>
<p>我们先来看看openZygoteSocketIfNeeded(abi),这个方法名称已经给出了它的作用：如果有必要则打开Zygote的Socket连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx &#123;</span><br><span class="line">     Preconditions.checkState(Thread.holdsLock(mLock), &quot;ZygoteProcess lock not held&quot;);</span><br><span class="line"></span><br><span class="line">     //未创建连接，这里就会调用ZygoteState.connect()进行连接</span><br><span class="line">     if (primaryZygoteState == null || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             primaryZygoteState = ZygoteState.connect(mSocket);</span><br><span class="line">         &#125; catch (IOException ioe) &#123;</span><br><span class="line">             throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">         return primaryZygoteState;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     //abi的架构可能有32位，64位两种，可以理解为一个主要架构和一个辅助架构。主架构不匹配的时候，会使用辅助架构模式。</span><br><span class="line">     // The primary zygote didn&apos;t match. Try the secondary.</span><br><span class="line">     if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">         try &#123;</span><br><span class="line">             secondaryZygoteState = ZygoteState.connect(mSecondarySocket);</span><br><span class="line">         &#125; catch (IOException ioe) &#123;</span><br><span class="line">             throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">         return secondaryZygoteState;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>不管使用哪种架构模式，我们第一次进来，肯定是还没有连接的，所以，这个时候会调用ZygoteState.connect()，</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487415981670.jpg" alt=""></p>
<p>根据openZygoteSocketIfNeeded中ZygoteState.connect(mSocket)，这个方法的参数是mSocket，这个是当前Socket需要连接的服务端地址，而这个mSocket又是从何而来？<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487417662487.jpg" alt=""></p>
<p>这是mSocke声明的位置，刚好可以看到这个属性是在ZygoteProcess初始化的时候带过来的。而ZygoteProcess 又是在哪里创建的呢？我们回到Process.start()</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487418866087.jpg" alt=""></p>
<p>在这里使用zygoteProcess实例，而他在Process中是这样声明的<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487419380911.jpg" alt=""></p>
<p>所以这里也是ZygoteProcess的创建位置，其中的两个参数分别是：<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487419808363.jpg" alt=""></p>
<p>看到这里，我们就知道了，ZygoteProcess.connect()连接的是zygote服务器。</p>
<p>看完openZygoteSocketIfNeeded() 我们再回到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote)</span><br></pre></td></tr></table></figure>
<p>zygoteSendArgsAndGetResult()也只是简单地将参数发送给服务器，并接收服务返回的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">private static Process.ProcessStartResult zygoteSendArgsAndGetResult(</span><br><span class="line">          ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span><br><span class="line">          throws ZygoteStartFailedEx &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          // Throw early if any of the arguments are malformed. This means we can</span><br><span class="line">          // avoid writing a partial response to the zygote.</span><br><span class="line">          int sz = args.size();</span><br><span class="line">          for (int i = 0; i &lt; sz; i++) &#123;</span><br><span class="line">              if (args.get(i).indexOf(&apos;\n&apos;) &gt;= 0) &#123;</span><br><span class="line">                  throw new ZygoteStartFailedEx(&quot;embedded newlines not allowed&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          /**</span><br><span class="line">           * See com.android.internal.os.SystemZygoteInit.readArgumentList()</span><br><span class="line">           * Presently the wire format to the zygote process is:</span><br><span class="line">           * a) a count of arguments (argc, in essence)</span><br><span class="line">           * b) a number of newline-separated argument strings equal to count</span><br><span class="line">           *</span><br><span class="line">           * After the zygote process reads these it will write the pid of</span><br><span class="line">           * the child or -1 on failure, followed by boolean to</span><br><span class="line">           * indicate whether a wrapper process was used.</span><br><span class="line">           */</span><br><span class="line">          final BufferedWriter writer = zygoteState.writer;</span><br><span class="line">          final DataInputStream inputStream = zygoteState.inputStream;</span><br><span class="line"></span><br><span class="line">          writer.write(Integer.toString(args.size()));</span><br><span class="line">          writer.newLine();</span><br><span class="line"></span><br><span class="line">          for (int i = 0; i &lt; sz; i++) &#123;</span><br><span class="line">              String arg = args.get(i);</span><br><span class="line">              writer.write(arg);</span><br><span class="line">              writer.newLine();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          writer.flush();</span><br><span class="line"></span><br><span class="line">          // Should there be a timeout on this?</span><br><span class="line">          Process.ProcessStartResult result = new Process.ProcessStartResult();</span><br><span class="line"></span><br><span class="line">          // Always read the entire result from the input stream to avoid leaving</span><br><span class="line">          // bytes in the stream for future process starts to accidentally stumble</span><br><span class="line">          // upon.</span><br><span class="line">          result.pid = inputStream.readInt();</span><br><span class="line">          result.usingWrapper = inputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">          if (result.pid &lt; 0) &#123;</span><br><span class="line">              throw new ZygoteStartFailedEx(&quot;fork() failed&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">          return result;</span><br><span class="line">      &#125; catch (IOException ex) &#123;</span><br><span class="line">          zygoteState.close();</span><br><span class="line">          throw new ZygoteStartFailedEx(ex);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>小结：</strong><br>1.Launcher中的点击事件开始startActivity()<br>2.ActivityStackSupervisor.startSpecificActivityLocked() 中判断进程为空，开始创建进程<br>3.AMS.startProcessLocked –&gt; Process.start–&gt;ZygoteProcess.start–&gt;ZygoteProcess.startViaZygote</p>
<p>ZygoteProcess.startViaZygote方法主要做三件事：</p>
<ul>
<li>构建需要发送给服务器的相关参数列表，这是ArrayList</li>
<li>连接系统服务端</li>
<li>将第一点中的参数发送给服务端</li>
</ul>
<p><br><br>在上一个小结中，我们反复说道，连接服务端，那这个服务端又是什么呢？这部分知识与系统的启动过程有关，不过没有关系，在这个章节中我们大概了解这部分知识就好了。</p>
<p>读者需要知道的是:系统启动之后会调用ZygoteInit.main()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//1.注册Socket服务，提供给客户端连接</span><br><span class="line">zygoteServer.registerServerSocket(socketName);</span><br><span class="line">// In some configurations, we avoid preloading resources and classes eagerly.</span><br><span class="line">// In such cases, we will preload things prior to our first fork.</span><br><span class="line">if (!enableLazyPreload) &#123;</span><br><span class="line">    //2.预加载</span><br><span class="line">    preload(bootTimingsTraceLog);</span><br><span class="line">   </span><br><span class="line">&#125; else &#123;</span><br><span class="line">    Zygote.resetNicePriority();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//3.启动服务</span><br><span class="line">if (startSystemServer) &#123;</span><br><span class="line">    startSystemServer(abiList, socketName, zygoteServer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Log.i(TAG, &quot;Accepting command socket connections&quot;);</span><br><span class="line">//4.开启socket的轮询</span><br><span class="line">zygoteServer.runSelectLoop(abiList);</span><br></pre></td></tr></table></figure>
<p>ZygoteInit.main主要做了四件事</p>
<ul>
<li>注册Socket服务，提供给客户端连接</li>
<li>预加载</li>
<li>启动系统服务</li>
<li>zygoteServer.runSelectLoop</li>
</ul>
<p>其中注册服务就是创建一个ServerSocket<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487437888305.jpg" alt=""></p>
<p>zygoteServer.runSelectLoop 则是调用zygote进程的select loop，用来接收客户端发起的连接请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">void runSelectLoop(String abiList) throws Zygote.MethodAndArgsCaller &#123;</span><br><span class="line">       ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">       ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">       fds.add(mServerSocket.getFileDescriptor());</span><br><span class="line">       peers.add(null);</span><br><span class="line"></span><br><span class="line">       while (true) &#123;</span><br><span class="line">           StructPollfd[] pollFds = new StructPollfd[fds.size()];</span><br><span class="line">           for (int i = 0; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">               pollFds[i] = new StructPollfd();</span><br><span class="line">               pollFds[i].fd = fds.get(i);</span><br><span class="line">               pollFds[i].events = (short) POLLIN;</span><br><span class="line">           &#125;</span><br><span class="line">           try &#123;</span><br><span class="line">               //这里一直在轮询，等待这客户端的连接</span><br><span class="line">               Os.poll(pollFds, -1);</span><br><span class="line">           &#125; catch (ErrnoException ex) &#123;</span><br><span class="line">               throw new RuntimeException(&quot;poll failed&quot;, ex);</span><br><span class="line">           &#125;</span><br><span class="line">           for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">               if ((pollFds[i].revents &amp; POLLIN) == 0) &#123;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125;</span><br><span class="line">               if (i == 0) &#123;</span><br><span class="line">                   //收到新的连接请求</span><br><span class="line">                   ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line">                   peers.add(newPeer);</span><br><span class="line">                   fds.add(newPeer.getFileDesciptor());</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   //连接成功之后的数据处理</span><br><span class="line">                   boolean done = peers.get(i).runOnce(this);</span><br><span class="line">                   if (done) &#123;</span><br><span class="line">                       peers.remove(i);</span><br><span class="line">                       fds.remove(i);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>收到连接请求之后，会先创建一个ZygoteConnect,然后调用runOnce。<br>在runOnce中有这几块代码<br>1.获取客户端发送过来的参数,并封装到Arguments，这里只截取部分头部代码。<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487441971363.jpg" alt=""></p>
<p>2.调用Zygote.forkAndSpecialize 从而fork出一个进程<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487442376188.jpg" alt=""></p>
<p>3.处理子进程<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487447463552.jpg" alt=""></p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487448561992.jpg" alt=""><br>在子进程中又调用了ZygoteInit.zygoteInit()<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487448847706.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);</span><br></pre></td></tr></table></figure>
<p>RuntimeInit.applicationInit<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487449875265.jpg" alt=""></p>
<p>RuntimeInit.invokeStaticMain</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)</span><br><span class="line">         throws Zygote.MethodAndArgsCaller &#123;</span><br><span class="line">     Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">     try &#123;</span><br><span class="line">         cl = Class.forName(className, true, classLoader);</span><br><span class="line">     &#125; catch (ClassNotFoundException ex) &#123;</span><br><span class="line">         throw new RuntimeException(</span><br><span class="line">                 &quot;Missing class when invoking static main &quot; + className,</span><br><span class="line">                 ex);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     Method m;</span><br><span class="line">     try &#123;</span><br><span class="line">         m = cl.getMethod(&quot;main&quot;, new Class[] &#123; String[].class &#125;);</span><br><span class="line">     &#125; catch (NoSuchMethodException ex) &#123;</span><br><span class="line">         throw new RuntimeException(</span><br><span class="line">                 &quot;Missing static main on &quot; + className, ex);</span><br><span class="line">     &#125; catch (SecurityException ex) &#123;</span><br><span class="line">         throw new RuntimeException(</span><br><span class="line">                 &quot;Problem getting static main on &quot; + className, ex);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     int modifiers = m.getModifiers();</span><br><span class="line">     if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">         throw new RuntimeException(</span><br><span class="line">                 &quot;Main method is not public and static on &quot; + className);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     /*</span><br><span class="line">      * This throw gets caught in ZygoteInit.main(), which responds</span><br><span class="line">      * by invoking the exception&apos;s run() method. This arrangement</span><br><span class="line">      * clears up all the stack frames that were required in setting</span><br><span class="line">      * up the process.</span><br><span class="line">      */</span><br><span class="line">     throw new Zygote.MethodAndArgsCaller(m, argv);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>RuntimeInit.invokeStaticMain 通过classname找到目标Class，并通过反射找到目标Class的启动方法main()，最后将方法和参数都封装到Zygote.MethodAndArgsCaller对象中，并抛出异常。<br>而这里抛出的异常最终在ZygoteInit.main中被捕获<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487453049937.jpg" alt=""><br>异常被捕获之后，直接执行了Zygote.MethodAndArgsCaller.run()<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487454144295.jpg" alt=""></p>
<p>这里的run方法也很简单，直接使用反射，调用我们刚才找到的main方法。</p>
<p>那么问题来了，我们找了半天的main方法，并且调用了，但是这个main方法是谁的呢？</p>
<p>我们回到RuntimeInit.applicationInit()<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487456127785.jpg" alt=""></p>
<p>反射调用静态的main方法，传入的是args.startClass字符串，这个字符在new Arguments(argv)中构建。<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487457114590.jpg" alt=""></p>
<p>解析参数的过程，可以看到，startClass是客户端传递过来的最后一个参数。我们回到客户端发送参数的位置往回找，<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487460737751.jpg" alt=""></p>
<p>我们看到processClass在Process.start中就作为参数传递进来了。那么，再往回看看。<br>ActivityManagerService.startProcessLocked()，entryPoint就是我们带过去的参数processClass<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487461541081.jpg" alt=""></p>
<p>ActivityManagerService.startProcessLocked()<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487461789309.jpg" alt=""></p>
<p>这的entryPoint是null，所以在上个代码片段中，我们就会执行<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487463163879.jpg" alt=""><br>那么，我们需要调用的目标类就可以确定了：android.app.ActivityThread，那么接下来就是直接调用ActivithThread.main()了。</p>
<blockquote>
<p>在invokeStaticMain()中为什么使用抛异常的方式来处理，而不是直接调用MethodAndArgsCaller.run 呢？<br>抛出异常再捕获，有个好处:可以清空之前的所有数据，保留一个较为干净的进程.</p>
</blockquote>
<p><strong>小结：</strong></p>
<p>看到这里，我们已经知道了AMS发送消息给服务端之后，服务端所做的处理。主要分为三部分</p>
<ol>
<li>在Zygote进程中，接收客户端的连接并创建了一个ZygoteConnect；</li>
<li>然后ZygoteConnect.run()中获取参数，fork出子进程；</li>
<li>在子进程中处理客户端传递过来参数，这里就是找到ActivityThread, 并调用其静态main方法。</li>
</ol>
<p><br><br>通过上个小结，我们已经fork出一个子进程，且子进程调用了ActivityThread.main()，那么我们就继续看看ActivityThread.main()又有哪些操作好了。</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487480086771.jpg" alt=""></p>
<p>首先在1中创建了一个消息队列，并在3中开始轮询消息队列。消息队列创建之后，2中就创建了一个ActivityThread并调用了ActivityThread.attach()<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487486401757.jpg" alt=""></p>
<p>attach中获取IActivityManager,并调用IActivityManger.attachApplication()</p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487486926251.jpg" alt=""></p>
<p>ActivityMangerService.attachApplication<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487487617244.jpg" alt=""></p>
<p>attachApplicationLocked将回调Thread.bindApplication()<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487488070786.jpg" alt=""></p>
<p><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487488269697.jpg" alt=""></p>
<p>handleBindApplication 主要做三件事情</p>
<ol>
<li><p>创建Instrumentation对象<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487493632458.jpg" alt=""></p>
</li>
<li><p>创建Application，并绑定<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487490125298.jpg" alt=""></p>
</li>
<li><p>安装ContentProviders<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487491825259.jpg" alt=""></p>
</li>
</ol>
<p>installContentProviders是ContentProviders的创建过程，这里暂不细说。</p>
<p>看完Application的创建和绑定，我们回到<br>AMS.attachApplicationLocked,在bindApplication之后我们还看到了这个方法<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487494666943.jpg" alt=""></p>
<p>ActivityStackSupervisor.attachApplicationLocked<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487495201782.jpg" alt=""></p>
<p>这里主要是遍历当前进程中的Activity栈，并通过realStartActivityLocked启动栈顶Activity。这个栈顶Activity就是最初点击桌面快捷键时，需要打开的Activity,也就是目标APP的启动页。<br><img src="/2019/01/29/Activity启动过程(二)/media/15487316429786/15487497072768.jpg" alt=""></p>
<p>realStartActivityLocked 中调用scheduleLaunchActivity，从而将AMS的调用过程回转给了ActivityThread。</p>
<p>之后Activity的启动过程，已经在Activity启动过程(一)中有详细的说明，这里不再赘述。</p>
<p><strong>小结:</strong><br>ActivityThread.main中完成两件事</p>
<ul>
<li>创建消息队列并不断轮询</li>
<li>调用ActivityThread.attach<ul>
<li>bindApplication</li>
<li>ActivityStackSupervisor.attachApplicationLocked()–&gt;realStartActivityLocked()</li>
</ul>
</li>
</ul>
<p>以上：当我们点击桌面快捷键启动一个App时，系统其实为我们做了这些事情</p>
<ol>
<li><p>桌面应用:调用startActivity</p>
</li>
<li><p>AMS准备打开Activity时发现目标APP未创建进程,与服务端创建连接，发送相关参数</p>
</li>
<li><p>zygote进程作为服务端</p>
<p> 2.1 服务器接收连接和参数<br> 2.2 fork子进程<br> 2.3 子进程中调用ActivityThread.main</p>
</li>
<li><p>ActivityThread.main<br> 4.1 创建消息队列并循环<br> 4.2 ActivityThread.attach(),在attach中将调用bindApplication()和ActivityStackSupervisor.attachApplicationLocked()–&gt;ActivityStackSupervisor.realStartActivityLocked</p>
</li>
<li><p>打开activity</p>
</li>
</ol>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    耀舞夕阳
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://zmylls.github.io/2019/01/29/Activity启动过程(二)/" title="">https://zmylls.github.io/2019/01/29/Activity启动过程(二)/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/28/Activity 启动过程(一)/" rel="next" title="HelloWorld">
                <i class="fa fa-chevron-left"></i> HelloWorld
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">耀舞夕阳</p>
              <p class="site-description motion-element" itemprop="description">Asher.zhang's blogs.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Activity启动过程-二"><span class="nav-number">1.</span> <span class="nav-text">Activity启动过程(二)</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ture</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
